---
date: "2022-11-24T11:35:01+06:00"
title: Case study with MCMC
weight: 4
---



<div id="introduction" class="section level3">
<h3>Introduction</h3>
<p><code>SAMtool</code> now supports MCMC sampling of the RCM using <a href="https://www.mc-stan.org">Stan</a> called through the <code>tmbstan</code> <a href="https://doi.org/10.1371/journal.pone.0197954">R package</a>. In this way, individual simulations within the operating model will be conditioned on individual draws of the MCMC chain.</p>
<p>Below is a schematic of the steps to setup the operating model using RCM and MCMC sampling. We will again use the <a href="../3-case-study">Pacific cod example</a> which sets up an age-structured model to mimic a delay-difference model, with knife-edge selectivity equal to knife-edge maturity.</p>
</div>
<div id="mpd-fit" class="section level3">
<h3>MPD fit</h3>
<p>The initial fit is generated by a function call to <code>RCM()</code> with a pre-made operating model (<code>OM</code>) and <code>RCMdata</code> object. This fit sets up the structure of the model, including any <a href="../../features-assessment-models/5-priors/">priors</a>:</p>
<pre class="r"><code>library(SAMtool)

#### Identify the maturity ogive to fix selectivity
data(pcod) 
mat_ogive &lt;- pcod$OM@cpars$Mat_age[1, , 1]

#### Remove stochastic samples of M and steepness, will estimate from prior
OM &lt;- pcod$OM
OM@cpars$M &lt;- OM@cpars$h &lt;- NULL
  
#### Update priors for M, h, and R0 (in addition to q)
prior &lt;- pcod$prior
prior$R0 &lt;- c(3, exp(1), exp(12))
prior$h &lt;- c(0.7, 0.15)
prior$M &lt;- c(0.5, 0.1)

#### MPD fit
MPD &lt;- RCM(OM = OM, data = pcod$data, 
           condition = &quot;catch&quot;, mean_fit = TRUE,
           selectivity = &quot;free&quot;, s_selectivity = rep(&quot;SSB&quot;, ncol(pcod$data@Index)),
           start = list(vul_par = matrix(mat_ogive, length(mat_ogive), 1)),
           map = list(vul_par = matrix(NA, length(mat_ogive), 1),
                      log_early_rec_dev = rep(1, OM@maxage)),
           prior = prior)</code></pre>
<p>The TMB model containing the MPD fit will be in <code>MPD@mean_fit$obj</code>.</p>
</div>
<div id="mcmc" class="section level3">
<h3>MCMC</h3>
<p>Once the MPD has been optimized, the <code>posterior()</code> function provides a convenient way to draw MCMC samples. This function is primarily a wrapper to <code>tmbstan::tmbstan()</code> which is also a wrapper to <code>rstan::sampling()</code>. Function arguments to <code>posterior()</code> configure the MCMC, e.g., the number of chains, iterations, thin rate, etc., and are passed on to these two functions.</p>
<pre class="r"><code>MCMC &lt;- posterior(MPD, chains = 2, iter = 2000, warmup = 1000, thin = 5)</code></pre>
<p>The MCMC object is a <code>stanfit</code> object containing the parameters from the saved MCMC draws. Therefore, any methods and diagnostic functions that supports Stan models can be used with the MCMC object. These functions can be used to determine how whether the MCMC has converged.</p>
<pre class="r"><code>#### Look at MCMC diagnostics (autocorrelation, wormplots, etc.)
sso &lt;- shinystan::launch_shinystan(MCMC)</code></pre>
</div>
<div id="update-rcm" class="section level3">
<h3>Update RCM</h3>
<p>Now that we have a converged MCMC, we can update the operating model from a subset of these MCMC draws with <code>RCMstan()</code>:</p>
<pre class="r"><code>#### Identify the simulations and chains from which to grab parameters from the MCMC object
sims &lt;- matrix(NA, OM@nsim, 2)
set.seed(234)
sims[, 1] &lt;- sample(MCMC@sim$chains, OM@nsim, replace = TRUE)
sims[, 2] &lt;- sample(MCMC@sim$n_save[1], OM@nsim)

#### Update RCM output and operating model
RCM_MCMC &lt;- RCMstan(MPD, MCMC, sims)</code></pre>
<p><code>RCMstan</code> returns an updated <code>RCModel</code> and we can generate an updated markdown report:</p>
<pre class="r"><code>plot(RCM_MCMC)</code></pre>
<p>We can now run the MSE with the conditioned operating model.</p>
<pre class="r"><code>MSE &lt;- runMSE(RCM_MCMC@OM, ...)</code></pre>
</div>
