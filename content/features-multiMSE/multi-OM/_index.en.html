---
date: "2022-03-16T11:35:01+06:00"
title: Multi-Operating Models
weight: 1
---



<div id="sub-sections" class="section level3">
<h3>Sub-Sections</h3>
<ul>
<li><a href="#the-mom-object">The MOM Object</a><br></li>
<li><a href="#stocks,-fleets,-obs,-and-imps">Stocks, Fleets, Obs, and Imps</a><br></li>
<li><a href="#catch-fractions-by-fleet-for-each-stock">Catch fractions by fleet for each stock</a><br></li>
<li><a href="#specifying-inter-stock-relationships">Specifying inter-stock relationships</a><br></li>
<li><a href="#constructing-the-mom-object">Constructing the MOM Object</a><br></li>
<li><a href="#single-stock-mom">Single Stock MOM</a><br></li>
<li><a href="#single-fleet-mom">Single Fleet MOM</a><br></li>
<li><a href="#a-unique-fleet-for-each-stock">A unique fleet for each stock</a><br></li>
</ul>
</div>
<div id="the-mom-object" class="section level3">
<h3>The MOM Object</h3>
<p>The <code>MOM</code> object is not terribly different from a standard <a href="/object-operating-model/">OM</a> object.</p>
<pre class="r"><code>slotNames(&#39;MOM&#39;)</code></pre>
<pre><code>##  [1] &quot;Name&quot;       &quot;Agency&quot;     &quot;Region&quot;     &quot;Sponsor&quot;    &quot;Latitude&quot;  
##  [6] &quot;Longitude&quot;  &quot;nsim&quot;       &quot;proyears&quot;   &quot;interval&quot;   &quot;pstar&quot;     
## [11] &quot;maxF&quot;       &quot;reps&quot;       &quot;cpars&quot;      &quot;seed&quot;       &quot;Source&quot;    
## [16] &quot;Stocks&quot;     &quot;Fleets&quot;     &quot;Obs&quot;        &quot;Imps&quot;       &quot;CatchFrac&quot; 
## [21] &quot;Allocation&quot; &quot;Efactor&quot;    &quot;Complexes&quot;  &quot;SexPars&quot;    &quot;Rel&quot;</code></pre>
<p>The big difference between objects of class <code>OM</code> and those of class <code>MOM</code> is that instead of including a slot for each parameter of the stock (<a href="/object-stock/">Stock</a>), fleet (<a href="/object-fleet/">Fleet</a>), observation (<a href="/object-obs/">Obs</a>) and implementation (<a href="/object-imp/">Imp</a>) models for <code>OM</code> objects, <code>MOM</code> objects include these in four slots that are lists of entire Stock, Fleet, Obs and Imp objects - after all it’s multi-fleet and/or multi stock, right?!</p>
</div>
<div id="stocks-fleets-obs-and-imps" class="section level3">
<h3>Stocks, Fleets, Obs, and Imps</h3>
<p>There are four new slots in an <code>MOM</code> object (compared to an <code>OM</code> object): <code>MOM@Stocks</code>, <code>MOM@Fleets</code>, <code>MOM@Obs</code>, and <code>MOM@Imps</code>.</p>
<ul>
<li><code>MOM@Stocks</code> is a list of stock objects (nstocks long)</li>
<li><code>MOM@Fleets</code> is a hierarchical list of fleet objects (nstocks with fleets nested in stocks)</li>
<li><code>MOM@Obs</code> is a hierarchical list of observation error objects (nstocks with fleets nested in stocks)</li>
<li><code>MOM@Imps</code> is a hierarchical list of implementation error objects (nstocks with fleets nested in stocks)</li>
</ul>
<p>Ideally you’d get your various dynamics from conditioned operating models either using the <a href="/tutorial-rcm/">Rapid Conditioning Model</a>
or using the various <code>openMSE</code> helper functions that read in <a href="/om-data-rich/">stock assessment output</a>. However, for simplicity we’ll demonstrate how to do <code>multiMSE</code> with some pre-existing Stock, Fleet, Obs, and Imp objects that are included in <code>openMSE</code>:</p>
<pre class="r"><code>avail(&#39;Stock&#39;)</code></pre>
<pre><code>## Searching for objects of class Stock in package: MSEtool</code></pre>
<pre><code>##  [1] &quot;Albacore&quot;          &quot;Blue_shark&quot;        &quot;Bluefin_tuna&quot;     
##  [4] &quot;Bluefin_tuna_WAtl&quot; &quot;Butterfish&quot;        &quot;Herring&quot;          
##  [7] &quot;Mackerel&quot;          &quot;Porgy&quot;             &quot;Rockfish&quot;         
## [10] &quot;Snapper&quot;           &quot;Sole&quot;              &quot;Toothfish&quot;</code></pre>
<pre class="r"><code>avail(&#39;Fleet&#39;)</code></pre>
<pre><code>## Searching for objects of class Fleet in package: MSEtool</code></pre>
<pre><code>##  [1] &quot;DecE_Dom&quot;              &quot;DecE_HDom&quot;             &quot;DecE_NDom&quot;            
##  [4] &quot;FlatE_Dom&quot;             &quot;FlatE_HDom&quot;            &quot;FlatE_NDom&quot;           
##  [7] &quot;Generic_DecE&quot;          &quot;Generic_FlatE&quot;         &quot;Generic_Fleet&quot;        
## [10] &quot;Generic_IncE&quot;          &quot;IncE_HDom&quot;             &quot;IncE_NDom&quot;            
## [13] &quot;Low_Effort_Non_Target&quot; &quot;Target_All_Fish&quot;       &quot;Targeting_Small_Fish&quot;</code></pre>
<pre class="r"><code>avail(&#39;Obs&#39;)</code></pre>
<pre><code>## Searching for objects of class Obs in package: MSEtool</code></pre>
<pre><code>## [1] &quot;Generic_Obs&quot;        &quot;Imprecise_Biased&quot;   &quot;Imprecise_Unbiased&quot;
## [4] &quot;Perfect_Info&quot;       &quot;Precise_Biased&quot;     &quot;Precise_Unbiased&quot;</code></pre>
<pre class="r"><code>avail(&#39;Imp&#39;)</code></pre>
<pre><code>## Searching for objects of class Imp in package: MSEtool</code></pre>
<pre><code>## [1] &quot;Overages&quot;    &quot;Perfect_Imp&quot;</code></pre>
<p>Let’s imagine that we lose our minds and decide to create a model that simulates interactions between bluefin tuna and herring (we think bluefin eat herring). We also want to simulate three fleets, a bluefin fleet, a herring fleet and a mixed fleet that somehow, against all the odds catches both bluefin and herring! About as hypothetical as it gets I know, but that is intentional - this is just a demonstration!</p>
<p>First, we start off by creating the list of stock objects, this is pretty easy:</p>
<pre class="r"><code>#                 Stock 1    Stock 2
Stocks &lt;- list(Bluefin_tuna, Herring)</code></pre>
<p>A key constraint here is that the Stock objects have the same number of areas (e.g. <code>Bluefin_tuna@nareas</code>).</p>
<p>We now want to create our fleets for these stocks. Our bluefin-only fleet has stable effort (premade fleet type <code>Generic_FlatE</code>) our herring-only fleet has increasing effort (premade fleet type <code>Generic_IncE</code>) and our mythical mixed fishery has decreasing effort (premade fleet type <code>Generic_DecE</code>).</p>
<p>This is the tricky bit.</p>
<p>Nominally, the same fleet occupies the same position for each stock. For example, ‘longline’ is fleet 1 for both bluefin and herring. However, the fleet interactions with the stocks can (and often will) be different - e.g. the trend in exploitation rate of the longline fleet may be stable for bluefin but decreasing for herring (in this admittedly bizarre case). That is why <code>multiMSE</code> requires the same number of fleets for each stock but you have to be able to specify unique fleet dynamics for each stock x fleet. For example <code>longline_stable_exploitation</code> could be Fleet 1 for bluefin and <code>longline_decreasing_exploitation</code> could be Fleet 1 for Herring - it is the same fleet but interacts differently with the two stocks.</p>
<p>A rare exception is if you have one fleet catching each stock. Then you can just have one fleet position for each stock and put the stock-specific fleet in position Fleet 1 for all stocks. Confused? I don’t blame you! But this should get clearer as you work through this guide.</p>
<p>To specify exploitation dynamics across stocks and fleets you create a hierarchical list structure (Fleets nested in Stocks):</p>
<pre class="r"><code>#                           Fleet 1         Fleet 2      Fleet 3
Fleets_both_Stocks &lt;- list(Generic_FlatE, Generic_IncE, Generic_DecE) 
Fleets &lt;- list( Fleets_both_Stocks, # Bluefin (position 1 in Stocks)
                Fleets_both_Stocks) # Herring (position 2 in Stocks)
# for the sake of this exercise we assume identical fleet dynamics for both stocks</code></pre>
<p>Since each of these Fleets is going to generate fishery data for each stock, they each need an observation model by stock and fleet. Just like the Fleets list, this is hierarchical - Fleets nested in Stocks. We are going to assume that we get good data (Precise and Unbiased) for bluefin and bad data (Imprecise and Biased) for herring.</p>
<pre class="r"><code>#                      Fleet 1             Fleet 2          Fleet 3
Bluefin_obs &lt;- list(Precise_Unbiased, Precise_Unbiased, Precise_Unbiased)
Herring_obs &lt;- list(Imprecise_Biased, Imprecise_Biased, Imprecise_Biased)
Obs &lt;- list(Bluefin_obs,    # Bluefin (position 1 in Stocks)
             Herring_obs)    # Herring (position 2 in Stocks)</code></pre>
<p>Lastly, we need to specify implementation error models for these, we are going to assume this is the same for both stocks and is fleet specific: perfect for the first 2 fleets and includes overages for the mixed fleet (fleet 3).</p>
<pre class="r"><code>#                        Fleet 1       Fleet 2     Fleet 3
Imp_both_Stocks &lt;- list(Perfect_Imp, Perfect_Imp, Overages)
Imps &lt;- list( Imp_both_Stocks,   # Bluefin (position 1 in Stocks)
              Imp_both_Stocks)   # Herring (position 2 in Stocks)</code></pre>
<p>Each of the stocks already has a prespecified range of depletion:</p>
<pre class="r"><code>Bluefin_tuna@D</code></pre>
<pre><code>## [1] 0.02 0.20</code></pre>
<pre class="r"><code>Herring@D</code></pre>
<pre><code>## [1] 0.05 1.00</code></pre>
<p>But how do we attribute the magnitude of historical exploitation among the various fleets?</p>
</div>
<div id="catch-fractions-by-fleet-for-each-stock" class="section level3">
<h3>Catch fractions by fleet for each stock</h3>
<p>To allow <code>multiMSE</code> to run we <em>need</em> an extra Thing 1, and <em>should</em> have an additional Thing 2 after that.</p>
<p>Thing 1 is the current (most recent year) catch fractions among fleets for each stock. This information is required to calculate the relative catchabilities among the fleets.</p>
<p>Catch fractions are a list (nstock long) of matrices. Suppose we want 80% of current bluefin catches to come from fleet 1, 1% from fleet 2 and 19% from fleet 3, and also 60% of herring catches to come from Fleet 2, 5% from fleet 1 and the remaining 35% of herring catches from Fleet 3, this is how you would specify that:</p>
<pre class="r"><code>nsim = 4
#                  Fleet1  Fleet2   Fleet3
bluefin_catchfrac&lt;-c(0.8,   0.01,   0.19)
herring_catchfrac&lt;-c(0.05,  0.6,    0.35)
CatchFrac &lt;- list(
                  matrix( rep(bluefin_catchfrac, each=nsim), nrow=nsim),
                  matrix( rep(herring_catchfrac, each=nsim), nrow=nsim)
)

CatchFrac[[1]]</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]  0.8 0.01 0.19
## [2,]  0.8 0.01 0.19
## [3,]  0.8 0.01 0.19
## [4,]  0.8 0.01 0.19</code></pre>
<p>The observant types among you will have noticed that we now need to specify the number of MSE simulations we are going to be doing (<code>nsim</code>). For now this is just 12 for demonstration purposes, but ultimately this would be &gt;148 for a real MSE.</p>
<p>The reason we have done this is to allow for uncertainty in the catch fractions - the user could make catch fractions vary among fleets by simulation. For now, these are the same among simulations, which is the simplest thing, albeit a bit boring.</p>
</div>
<div id="specifying-inter-stock-relationships" class="section level3">
<h3>Specifying inter-stock relationships</h3>
<p>You’ll remember that we said there was a Thing 2 that we should add to our multi-operating model. Ask yourself why we are modelling bluefin and herring together?</p>
<p>Because we want to look at an interaction between these stocks. If we didn’t, we would just model these stocks individually, and there would be only one stock in the Stocks slot and only one list of fleets in the Fleets slot (the remaining reason for modelling many stock without interactions is if they are managed by a single MP as a stock complex - we’ll come to this in a bit).</p>
<p>If we didn’t expect to set fleet-specific advice AND we weren’t modelling bluefin and herring interactions, we should just be using the regular <code>runMSE</code> and calculate the aggregate fleet dynamics (aggregate size vulnerability and trend in apical fishing mortality rate, for example).</p>
<p>But we’re demonstrating <code>multiMSE</code> here, and are therefore going to specify at least one relationship between the stocks (noting that you may wish to evaluate MPs that provide advice for a stock complex of multiple stock objects with no interactions - more below). The slot <code>MOM@Rel</code> is where you put these relationships as a list of R models with quite specific formatting.</p>
<p>Since we think bluefin are predators of herring, we are going to propose a relationship between bluefin abundance and the natural mortality rate of herring. Normally we would have derived this relationship empirically from data (in this case perhaps herring tagging survival estimates regressed on bluefin abundance estimates from a stock assessment).</p>
<p>However for the purposes of this demonstration we’re just going to cook something up out of thin air: nominally we are going to assume that herring have a natural mortality rate of 0.2 when there are no bluefin, and 0.4 when bluefin tuna are at unfished levels. To invent this relationship we are going to need to calculate bluefin unfished biomass from the operating model, make some fake data and fit an R model.</p>
<p>Here goes:</p>
<pre class="r"><code>ages &lt;- 1:60
bf_M &lt;- mean(Bluefin_tuna@M)          # natural mortality rate
bf_Linf &lt;- mean(Bluefin_tuna@Linf)    # asymptotic length
bf_K &lt;- mean(Bluefin_tuna@K)          # von Bertalanffy growth parameter K
bf_t0 &lt;- mean(Bluefin_tuna@t0)        # von B. theoretical age at length zero
bf_R0 &lt;- Bluefin_tuna@R0              # unfished recruitment

bf_surv &lt;- bf_R0*exp(-bf_M*(ages-1))             # survival
bf_wt_age &lt;- bf_Linf*(1-exp(-bf_K*(ages-bf_t0))) # weight at age   
bf_unfished &lt;- sum(bf_R0*bf_surv*bf_wt_age)      # approxiate estimate of unfished biomass

M_err &lt;- rlnorm(100,0,0.05)
M_2 &lt;- seq(0.2,0.4,length.out=100) * M_err  # made up herring (stock 2) M values
B_1 &lt;- seq(0,bf_unfished,length.out=100)    # made up bluefin tuna abundance levels

dat &lt;- data.frame(M_2,B_1)
bfB_hM &lt;- lm(M_2~B_1,dat=dat) # a linear model predicting M for stock 2 from biomass B for stock 1
summary(bfB_hM)</code></pre>
<pre><code>## 
## Call:
## lm(formula = M_2 ~ B_1, data = dat)
## 
## Residuals:
##       Min        1Q    Median        3Q       Max 
## -0.038071 -0.010115  0.000254  0.008596  0.042786 
## 
## Coefficients:
##              Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) 1.974e-01  3.165e-03   62.37   &lt;2e-16 ***
## B_1         3.829e-10  1.001e-11   38.24   &lt;2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.01595 on 98 degrees of freedom
## Multiple R-squared:  0.9372, Adjusted R-squared:  0.9366 
## F-statistic:  1463 on 1 and 98 DF,  p-value: &lt; 2.2e-16</code></pre>
<pre class="r"><code>Rel &lt;- list(bfB_hM)</code></pre>
<pre class="r"><code>plot(dat$B_1, dat$M_2,pch=19, xlab = &quot;Bluefin biomass&quot;, ylab = &quot;Herring natural mortality&quot;)
lines(dat$B_1, predict(bfB_hM,newdat=dat), col = &#39;red&#39;, lwd = 2)
points(dat$B_1, simulate(bfB_hM,nsim=1,newdat=dat)[, 1], col = &#39;green&#39;)
legend(&#39;topleft&#39;,legend = c(&quot;made up data&quot;, &quot;best fit&quot;, &quot;simulated&quot;), text.col = c(&#39;black&#39;,&#39;red&#39;,&#39;green&#39;))</code></pre>
<p><img src="/features-multiMSE/multi-OM/_index.en_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<p>That is a lot to take in.</p>
<p>We derived a rough level of unfished bluefin biomass, made up some data (normally we would hope to have collected these) with log-normal error in herring <em>M</em>. We then fitted an R model (red line) and also demonstrated that we could use the <code>simulate</code> R function to simulate (green points) some new data based on that fit. Lastly, we placed our fitted model in a mysterious slot <code>Rel.</code></p>
<p>Here are the important things to know about inter-stock relationships listed in the <code>Rel</code> slot:</p>
<p>Any R model can be used that:</p>
<ul>
<li>is compatible with the function <code>simulate</code></li>
<li>has specific coding for independent (e.g. the bluefin biomass) and dependent variables (e.g. the herring natural mortality rate)</li>
</ul>
<p>The coding of independent variables goes like this:</p>
<ul>
<li>B = total stock biomass</li>
<li>SSB = total spawning stock biomass</li>
<li>N = total stock numbers</li>
</ul>
<p>The coding of dependent variables goes like this:</p>
<ul>
<li>M = Natural mortality rate of mature individuals</li>
<li>K = von Bertalanffy growth parameter K</li>
<li>Linf = asymtotic size Linf</li>
<li>t0 = von Bertalanffy theoretical age at length-0 t0</li>
<li>a = weight length parameter a (<span class="math inline">\(W=aL^b\)</span>)</li>
<li>b = weight length parameter b (<span class="math inline">\(W=aL^b\)</span>)</li>
<li>hs = steepness of the Beverton-Holt or Ricker stock recruitment function</li>
</ul>
<p>The underscore_then_number denotes the stock. So SSB_5 is the spawning stock biomass of the fifth stock in the Stocks slot, Linf_2 is the asymptotic length of stock 2 in the stocks slot.</p>
<p>Currently there can only be one dependent variable but many independent variables so this model is possible:</p>
<pre><code>M_3 ~ B_1 + B_2 - B_4</code></pre>
<p>You can’t have transformed independent variables but you can transform the dependent variables so this model is possible:</p>
<pre><code>hs_3 ~ log(B_2) * log(B_1)</code></pre>
<p>but not this:</p>
<pre><code>log(hs_3) ~ B_2 + B_1</code></pre>
<p>And another thing, the order you place these in the <code>Rel</code> slot determines the order in which they operate. This may not be consequential yet, but plans are in the works to let an dependent variable in one relationship be the independent in the next.</p>
<p>The idea behind the <code>Rel</code> slot of the <code>MOM</code> object is to open up the option of including ecosystem driven relationships in a terse ‘models of intermediate complexity’ (MICE) format.</p>
<p>A note of caution before you go hog-wild with the <code>Rel</code> slot: it is probably fairly easy to set up a set of relationships and stock depletions that are impossible to solve in the initialization of the operating models in <code>multiMSE.</code> We haven’t had this issue yet, but do give some thought about the proposed relationships before you, for example, make herring <em>M</em> = 5 when bluefin depletion is 0.1 and then specify bluefin depletion as 0.1 and herring at 0.8 …</p>
</div>
<div id="constructing-the-mom-object" class="section level3">
<h3>Constructing the MOM Object</h3>
<p>Now we have six lists:</p>
<ol style="list-style-type: decimal">
<li>Stocks</li>
<li>Fleets</li>
<li>Obs</li>
<li>Imps</li>
<li>CatchFrac</li>
<li>Rel</li>
</ol>
<p>We can construct an object of class MOM:</p>
<pre class="r"><code>MOM_BH &lt;- new(&#39;MOM&#39;, Stocks, Fleets, Obs, Imps, CatchFrac, Rel = Rel, nsim = nsim)</code></pre>
</div>
<div id="single-stock-mom" class="section level3">
<h3>Single Stock MOM</h3>
<p>If you wish to specify only a single stock but multiple fleets (e.g. just bluefin above) that is pretty easy:</p>
<pre class="r"><code>Stocks &lt;-    list( Bluefin_tuna )
Fleets &lt;-    list( list(Generic_FlatE, Generic_IncE, Generic_DecE) )
Obs &lt;-       list( list(Precise_Unbiased, Precise_Unbiased, Precise_Unbiased) ) 
Imps &lt;-      list( list(Perfect_Imp, Perfect_Imp, Overages) )
CatchFrac &lt;- list( matrix( rep(c(0.8,   0.01,   0.19), each=nsim), nrow=nsim) )

MOM_1S &lt;- new(&#39;MOM&#39;, Stocks, Fleets, Obs, Imps, CatchFrac, nsim=nsim)</code></pre>
<p><code>Stocks</code> is just a list 1 stock object long. <code>CatchFrac</code> is a list 1 stock long of catch fractions by simulation and fleet. For any hierarchical list (<code>Fleets</code>, <code>Obs</code>, <code>Imps</code>) there is just one position (one stock) in which you have to place a list of <code>Fleet</code>, <code>Obs</code> and <code>Imp</code> objects.</p>
</div>
<div id="single-fleet-mom" class="section level3">
<h3>Single Fleet MOM</h3>
<p>If you want to model multiple stocks but are happy with aggregate fleet dynamics for each stock, that is fairly straight forward:</p>
<pre class="r"><code>#                     Stock 1    Stock 2
Stocks &lt;-    list( Bluefin_tuna, Herring )
#                         Bluefin                Herring            
Fleets &lt;-    list(  list(Generic_FlatE),    list(Generic_FlatE)    )
Obs &lt;-       list( list(Precise_Unbiased), list(Imprecise_Biased) )  
Imps &lt;-      list(   list(Perfect_Imp),       list(Overages)      )

MOM_1F &lt;- new(&#39;MOM&#39;, Stocks, Fleets, Obs, Imps, Rel = Rel, nsim=nsim)</code></pre>
<p>Note we no longer have to specify <code>CatchFrac</code> as we do not have to calculate fleet-specific catchabilties using observed recent catch fractions.</p>
</div>
<div id="a-unique-fleet-for-each-stock" class="section level3">
<h3>A unique fleet for each stock</h3>
<p>If you wish to model many stocks but in each case you are able to aggregate fleet dynamics (a single fleet), then you do exactly as above for the single fleet case but put a stock specific-fleet in position 1:</p>
<pre class="r"><code>#                     Stock 1    Stock 2  Stock 3
Stocks &lt;-    list( Bluefin_tuna, Herring, Mackerel )
#                         Bluefin fleet           Herring fleet       Mackerel fleet          
Fleets &lt;-    list(  list(Generic_FlatE),    list(Generic_IncE),     list(Generic_DecE)    )
Obs &lt;-       list( list(Precise_Unbiased), list(Imprecise_Biased),  list(Precise_Biased) )  
Imps &lt;-      list(   list(Perfect_Imp),       list(Overages),       list(Overages)      )
CatchFrac &lt;- list( matrix(1, nrow=nsim),   matrix(1, nrow=nsim),    matrix(1, nrow=nsim) )

MOM_FS &lt;- new(&#39;MOM&#39;, Stocks, Fleets, Obs, Imps, CatchFrac, Rel = Rel, nsim=nsim)</code></pre>
<p>One way or another we have our multi operating model, now we need some MPs to test …</p>
</div>
