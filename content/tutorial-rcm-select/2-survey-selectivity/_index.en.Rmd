---
date: "2021-01-21T11:35:01+06:00"
title: Index selectivity and catchability
weight: 2
---

```{r echo = FALSE, message = FALSE}
library(SAMtool, quietly = TRUE)
OM <- MSEtool::testOM
RCMdata <- new("RCMdata")

#vul_par_easy <- matrix(c(55, 30, 1, 55, 30, 0.5, 20, 19, 0.9), 3, 3)
#vul_par_free <- matrix(c(55, 30, 1, rep(NA, 3), 45, 30, 0.5, rep(NA, 3), 0.1, 0.3, 0.7, 1, 1, 1), 6, 3)

```

Next, we can move on to index selectivity. Unlike fleet selectivity, selectivity is unique to each index and no dummy fleets are used.

### Is index selectivity already defined elsewhere?

The vector `s_selectivity` defines where the index selectivity is defined (the terms index and survey are used interchangeably). Index selectivity may be identical to fleet selectivity, i.e., vulnerable biomass, or could be related to spawning or total biomass. If we have 4 indices with:

```{r}
s_selectivity <- c("SSB", "B", 1, 2)
```

The first index is an index of spawning biomass as denoted by "SSB" (maturity is configured in the `OM`), the second index tracks total biomass as denoted by "B" (selectivity = 1 for all ages), and the third and fourth indices have the selectivity of the first and second fleets, respectively. Integers for fleets refer to the true fleet and not to selectivity blocks/dummy fleets. 

No further consideration of index selectivity is needed when defined elsewhere, and the `RCM` function call can look like this:

```{r eval = FALSE}
output <- RCM(OM, RCMdata, selectivity = selectivity, 
              s_selectivity = s_selectivity, 
              ...)
```

### Index selectivity is independent of anything else in the model

On the other hand, if index selectivity needs to be explicitly defined, then the `s_selectivity` vector can indicate the functional form, using one of `logistic`, `dome`, or `free`. Let's look at another situation with 5 indices with this selectivity definition:

```{r}
s_selectivity <- c(2, "SSB", "B", "dome", "free")
```

For the fourth and fifth index, the selectivity functions are dome-shaped and free parameters, respectively. We will need to consider what the parameters defining this functions are, either as starting values to be estimated or fixed values in the model.

#### Selectivity parameters

Just as with the fleet selectivity parameters, the index selectivity parameters by default use `OM@LFS`, `OM@L5`, and `OM@Vmaxlen` for start values when `s_selectivity = "logistic"` or `"dome"`. Custom start values are needed when index selectivity uses free parameters. 

Custom start values are passed to the RCM in the `start$ivul_par` matrix with the same dimension and layout as for `start$vul_par`:

```{r echo = FALSE}
ivul_par <- matrix(c(rep(0, 18), 55, 40, 0.5, rep(0, 3), 1, rep(0, 5)), 6, 5)
```
```{r}
OM@maxage <- 5
s_selectivity <- c(2, "SSB", "B", "dome", "free")
ivul_par
```

Parameter slots for index 1-3 in the first three columns are ignored. Again they're placeholders for internal organization. The first three rows in column four are the start values for the three parameters of the dome function (to be estimated), and the fifth index only selects age-0 animals, i.e., an index of recruits.

Finally, to remove parameters from estimation either because they're just placeholders (indices 1-3) or they should be fixed in the model (index 5), we provide the map argument for `ivul_par` with `map$ivul_par`:

```{r echo = FALSE}
map_ivul_par <- matrix(NA, 6, 5)
map_ivul_par[1:3, 4] <- 1:3
```
```{r}
map_ivul_par
```

A function call utilizing this custom set-up for index selectivity would be:

```{r eval = FALSE}
output <- RCM(OM, data, selectivity = selectivity, 
              s_selectivity = s_selectivity, 
              start = list(ivul_par = ivul_par), 
              map = list(ivul_par = map_ivul_par), 
              ...)
```

### Index catchability

By default, each index series is time-invariant with respect to the selectivity and catchability ($q$). By default, catchability for index $s$ is solved analytically in the model,

$$
q_s = \exp\left(\dfrac{\sum_y \log(I^{\textrm{obs}}_{y,s}) - \sum_y \log(x_{y,s})}{n_s}\right)
$$

where $I$ is the observed index, $x$ is the biomass or abundance vulnerable to the index, and $n_s$ is the number of data points.

This section goes through the three use cases if one or both of selectivity and catchability changes.

#### Case 1 - Both catchability and selectivity change

Simply break the index into two series and model them separately.

#### Case 2 - Catchability changes but selectivity does not

Break the index into two series and map the selectivity parameters so that the two series share the same parameters (see selectivity section above).

#### Case 3 - Catchability is constant but selectivity changes

Break the index into two series. Then use the map argument to identify the index series which share a common $q$. As an example with 5 index series,

```{r map-q, eval=FALSE}
RCM(..., map = list(q = c(1, 1, 2, 2, NA)))
```

This map argument sets up the model so that index series 1 & 2 share one $q$ parameter and series 3 and 4 share another $q$ parameter. When map is an integer, $q$ is an estimated parameter while `r NA` for the fifth index indicates that $q$ will be calculated analytically.

#### Fixing catchability

RCM provides an option for fixing catchability to one:

```{r abs-I, eval=FALSE}
RCMdata@abs_I <- c(0, 0, 0, 0, 1)
```

where $q = 1$ for the fifth index.

There are two ways to fix $q$ to an alternative value. First, rescale the index such that the new index will have $q=1$. Second, set the q prior to with a tight prior:

```{r q-prior-abs-I, eval=FALSE}
prior <- list()
prior$q <- matrix(NA, 5, 2)
prior$q[5, ] <- c(0.5, 0.001)
  
RCM(..., prior = prior)
```

where the $q$ for the fifth index has a prior mean of 0.5 and lognormal standard deviation of 0.001.

#### Offset catchability

If two index series have offset catchability, e.g., the $q$ of one index is twice of another index, simply re-scale one of them and share the $q$ parameter between the two.

