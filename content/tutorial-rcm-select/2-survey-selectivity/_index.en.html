---
date: "2021-01-21T11:35:01+06:00"
title: Index selectivity and catchability
weight: 2
---



<p>Next, we can move on to index selectivity. Unlike fleet selectivity, selectivity is unique to each index and no dummy fleets are used.</p>
<div id="is-index-selectivity-already-defined-elsewhere" class="section level3">
<h3>Is index selectivity already defined elsewhere?</h3>
<p>The vector <code>s_selectivity</code> defines where the index selectivity is defined (the terms index and survey are used interchangeably). Index selectivity may be identical to fleet selectivity, i.e., vulnerable biomass, or could be related to spawning or total biomass. If we have 4 indices with:</p>
<pre class="r"><code>s_selectivity &lt;- c(&quot;SSB&quot;, &quot;B&quot;, 1, 2)</code></pre>
<p>The first index is an index of spawning biomass as denoted by “SSB” (maturity is configured in the <code>OM</code>), the second index tracks total biomass as denoted by “B” (selectivity = 1 for all ages), and the third and fourth indices have the selectivity of the first and second fleets, respectively. Integers for fleets refer to the true fleet and not to selectivity blocks/dummy fleets.</p>
<p>No further consideration of index selectivity is needed when defined elsewhere, and the <code>RCM</code> function call can look like this:</p>
<pre class="r"><code>output &lt;- RCM(OM, RCMdata, selectivity = selectivity, 
              s_selectivity = s_selectivity, 
              ...)</code></pre>
</div>
<div id="index-selectivity-is-independent-of-anything-else-in-the-model" class="section level3">
<h3>Index selectivity is independent of anything else in the model</h3>
<p>On the other hand, if index selectivity needs to be explicitly defined, then the <code>s_selectivity</code> vector can indicate the functional form, using one of <code>logistic</code>, <code>dome</code>, or <code>free</code>. Let’s look at another situation with 5 indices with this selectivity definition:</p>
<pre class="r"><code>s_selectivity &lt;- c(2, &quot;SSB&quot;, &quot;B&quot;, &quot;dome&quot;, &quot;free&quot;)</code></pre>
<p>For the fourth and fifth index, the selectivity functions are dome-shaped and free parameters, respectively. We will need to consider what the parameters defining this functions are, either as starting values to be estimated or fixed values in the model.</p>
<div id="selectivity-parameters" class="section level4">
<h4>Selectivity parameters</h4>
<p>Just as with the fleet selectivity parameters, the index selectivity parameters by default use <code>OM@LFS</code>, <code>OM@L5</code>, and <code>OM@Vmaxlen</code> for start values when <code>s_selectivity = "logistic"</code> or <code>"dome"</code>. Custom start values are needed when index selectivity uses free parameters.</p>
<p>Custom start values are passed to the RCM in the <code>start$ivul_par</code> matrix with the same dimension and layout as for <code>start$vul_par</code>:</p>
<pre class="r"><code>OM@maxage &lt;- 5
s_selectivity &lt;- c(2, &quot;SSB&quot;, &quot;B&quot;, &quot;dome&quot;, &quot;free&quot;)
ivul_par</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5]
## [1,]    0    0    0 55.0    1
## [2,]    0    0    0 40.0    0
## [3,]    0    0    0  0.5    0
## [4,]    0    0    0  0.0    0
## [5,]    0    0    0  0.0    0
## [6,]    0    0    0  0.0    0</code></pre>
<p>Parameter slots for index 1-3 in the first three columns are ignored. Again they’re placeholders for internal organization. The first three rows in column four are the start values for the three parameters of the dome function (to be estimated), and the fifth index only selects age-0 animals, i.e., an index of recruits.</p>
<p>Finally, to remove parameters from estimation either because they’re just placeholders (indices 1-3) or they should be fixed in the model (index 5), we provide the map argument for <code>ivul_par</code> with <code>map$ivul_par</code>:</p>
<pre class="r"><code>map_ivul_par</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5]
## [1,]   NA   NA   NA    1   NA
## [2,]   NA   NA   NA    2   NA
## [3,]   NA   NA   NA    3   NA
## [4,]   NA   NA   NA   NA   NA
## [5,]   NA   NA   NA   NA   NA
## [6,]   NA   NA   NA   NA   NA</code></pre>
<p>A function call utilizing this custom set-up for index selectivity would be:</p>
<pre class="r"><code>output &lt;- RCM(OM, data, selectivity = selectivity, 
              s_selectivity = s_selectivity, 
              start = list(ivul_par = ivul_par), 
              map = list(ivul_par = map_ivul_par), 
              ...)</code></pre>
</div>
</div>
<div id="index-catchability" class="section level3">
<h3>Index catchability</h3>
<p>By default, each index series is time-invariant with respect to the selectivity and catchability (<span class="math inline">\(q\)</span>). By default, catchability for index <span class="math inline">\(s\)</span> is solved analytically in the model,</p>
<p><span class="math display">\[
q_s = \exp\left(\dfrac{\sum_y \log(I^{\textrm{obs}}_{y,s}) - \sum_y \log(x_{y,s})}{n_s}\right)
\]</span></p>
<p>where <span class="math inline">\(I\)</span> is the observed index, <span class="math inline">\(x\)</span> is the biomass or abundance vulnerable to the index, and <span class="math inline">\(n_s\)</span> is the number of data points.</p>
<p>This section goes through the three use cases if one or both of selectivity and catchability changes.</p>
<div id="case-1---both-catchability-and-selectivity-change" class="section level4">
<h4>Case 1 - Both catchability and selectivity change</h4>
<p>Simply break the index into two series and model them separately.</p>
</div>
<div id="case-2---catchability-changes-but-selectivity-does-not" class="section level4">
<h4>Case 2 - Catchability changes but selectivity does not</h4>
<p>Break the index into two series and map the selectivity parameters so that the two series share the same parameters (see selectivity section above).</p>
</div>
<div id="case-3---catchability-is-constant-but-selectivity-changes" class="section level4">
<h4>Case 3 - Catchability is constant but selectivity changes</h4>
<p>Break the index into two series. Then use the map argument to identify the index series which share a common <span class="math inline">\(q\)</span>. As an example with 5 index series,</p>
<pre class="r"><code>RCM(..., map = list(q = c(1, 1, 2, 2, NA)))</code></pre>
<p>This map argument sets up the model so that index series 1 &amp; 2 share one <span class="math inline">\(q\)</span> parameter and series 3 and 4 share another <span class="math inline">\(q\)</span> parameter. When map is an integer, <span class="math inline">\(q\)</span> is an estimated parameter while NA for the fifth index indicates that <span class="math inline">\(q\)</span> will be calculated analytically.</p>
</div>
<div id="fixing-catchability" class="section level4">
<h4>Fixing catchability</h4>
<p>RCM provides an option for fixing catchability to one:</p>
<pre class="r"><code>RCMdata@abs_I &lt;- c(0, 0, 0, 0, 1)</code></pre>
<p>where <span class="math inline">\(q = 1\)</span> for the fifth index.</p>
<p>There are two ways to fix <span class="math inline">\(q\)</span> to an alternative value. First, rescale the index such that the new index will have <span class="math inline">\(q=1\)</span>. Second, set the q prior to with a tight prior:</p>
<pre class="r"><code>prior &lt;- list()
prior$q &lt;- matrix(NA, 5, 2)
prior$q[5, ] &lt;- c(0.5, 0.001)
  
RCM(..., prior = prior)</code></pre>
<p>where the <span class="math inline">\(q\)</span> for the fifth index has a prior mean of 0.5 and lognormal standard deviation of 0.001.</p>
</div>
<div id="offset-catchability" class="section level4">
<h4>Offset catchability</h4>
<p>If two index series have offset catchability, e.g., the <span class="math inline">\(q\)</span> of one index is twice of another index, simply re-scale one of them and share the <span class="math inline">\(q\)</span> parameter between the two.</p>
</div>
</div>
